= OpenBSD Malloc Implementation
:author: mulander
:authorNick: mulander
:email: mulander@openbsd.org
:editor: Mathieu Kerjouan
:editorNick: niamtokik
:editorEmail: contact@steepath.eu
:date: 2017-06-17
:revision: 2017-06-18
:copyright: CC-BY-4.0
:copyrightUrl: https://creativecommons.org/licenses/by/4.0/
:description: Read how malloc is implemented on OpenBSD
:keywords: malloc,kernel,implementation
:originUrl: https://junk.tintagel.pl/openbsd-daily-malloc-1.txt
:source: #openbsd-daily
:sourceUrl: `irc://irc.freenode.net/{source}`
:lang: en
:toc2:
:icons:
:data-uri:

:MAN:    https://man.openbsd.org
:CVS:    https://cvsweb.openbsd.org/cgi-bin/cvsweb
:BXR:    http://bxr.su/OpenBSD
:GITHUB: https://github.com
:GIST:   https://gist.github.com

== License

{copyright}.
ifdef::copyrightUrl[]
Full license is available at this URL: {copyrightUrl}.
endif::copyrightUrl[]

== Acknowledgement

ifdef::author[]
This document was originaly created ({date}) by {author} a.k.a
{authorNick} <{email}>.
endif::[]

ifdef::source[]
Raw documentation source is available at {originUrl} and was recorded
from {sourceUrl}.
endif::source[]

ifdef::editor[]
This document was edited ({revision}) by {editor} a.k.a {editorNick}
<{editorEmail}>.
endif::editor[]

== Summary

{description}

== On malloc and its implementation in OpenBSD

`malloc` is implemented in {BXR}/lib/libc/stdlib/malloc.c[`malloc.c`]
and man page is available in {MAN}/malloc[`malloc(3)`].

Interesting stuff can be read on http://www.drijf.net/malloc/[drijf
OpenBSD malloc implementation] page. You can also find a
https://www.openbsd.org/papers/eurobsdcon2009/otto-malloc.pdf[nice
presentation] from 2009 EuroBSDCon Edition.

Quickly going over the slides, will copy things that stood out to me.
Kernel knows two ways of giving memory to an application:
{MAN}/sbrk[`sbrk(2)`] and {MAN}/mmap[`mmap(2)`].

The {MAN}/brk[`brk(2)`] and {MAN}/sbrk[`sbrk(2)`] functions are
historical curiosities left over from earlier days before the advent
of virtual memory management. The virtual memory system for OpenBSD is
documented at {MAN}/uvm.9[`uvm(9)`]. Originally `malloc`
implementations were predictable, memory was rarely
cleared/randomized, frequently reused.

The OpenBSD `malloc` makes sure to return pages at random locations
(instead of grabbing a sequence of memory from the kernel, slicing it
into chunks and giving out consecutive chunks on each call). It works
on non-contiguous ranges of pages which means that overruning an
allocated buffer will more likely result in a crash instead of hitting
a second allocated page of memory.

Design goals from the pdf: simple, unpredictable, fast, less metadata
space overhead, robust (eg. double frees being detected).The doc now
goes into some implementation details (they might or might not be
outdated but worth to go over it).

There's apparently a hash table used that tracks mmap'ed regions using
their addresses as keys.  The existing data structure for chunk
allocations probably refers to the page dir? Not sure at this
point. There's also a cache for free regions. Slide 13 presents a nice
graph for the metadata.

Slide 14, we see a struct for `region_info` and a hashing function.
The backing hash table is grown if it crosses the 75% capacity water
mark.  The cache, freed regions are kept for potential reuse, large
regions are unmapped directly.  If the number of cached pages grows
they can get unmapped. The search for a cached region is randomized

Optionally pages are marked `PROT_NONE` which means the pages can't
be executed, read or written to.

NOTE: That's great for catching use-after-free bugs. You can enable
      this with malloc options. Would that also catch double free?
      Yes. The optional option `F` turns off delayed freeing. So that
      makes it easier to catch double frees I don't think the mprotect
      plays a role in this case.

The {MAN}/free[`free(3)`] function causes the space pointed to by
pointer to be either placed on a list of free blocks to make it
available for future allocation or, when appropriate, to be returned
to the kernel using {MAN}/munmap[`munmap(2)`]. If pointer is NULL, no
action occurs. If pointer was previously freed by
{MAN}/free[`free(3)`] or a reallocation function, the behavior is
undefined and the double free is a security concern.

NOTE: C arguments are always passed by value and it can't modify the
      pointer you pass to it. But a `free` would cause the pointer to
      be erased from the hash table mentioned earlier.

When the pointer isn't found in the hash table, free return an error
and this behavior can be see in
{BXR}/lib/libc/stdlib/malloc.c#1331[`malloc.c`] on line 1331.

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
if (r == NULL)
    wrterror(pool, "bogus pointer (double free?) %p", p);
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

{BXR}/realloc[`realloc(3)`] attempts to avoid mmap'ing more memory
from the kernel by checking if the required pages are already
existing. The {BXR}/lib/libc/stdlib/malloc.c#dir_info[`dir_info`] hash
is mmap'ed with `PROT_READ` (read only) and there's an option to do
the same for the page directory.
{BXR}/lib/libc/stdlib/malloc.c#dir_info[`dir_info`] and
{BXR}/lib/libc/stdlib/malloc.c#chunk_info[`chunk_info`] are also
protected by canaries and we learn this `malloc` first appeared in BSD
4.4.  That's it for the pdf.

Doing a quick scan though the site itself. We learn that malloc can
grab instrumentation data if built with
{BXR}lib/libc/stdlib/malloc.c#26[`MALLOC_STATS`] defined and not
compiled in by default and with that option malloc additionally
{BXR}/lib/libc/stdlib/malloc.c#106[tracks the source of the
allocation].

NOTE: This was introduced in a time before the valgrind port for
      OpenBSD (I still don't know how well it works, never tried
      it?). So that's one way to look out for and track memory leaks.

I'm currently iterating over defines for `MALLOC_STATS` to see what
code gets compiled in.  not going into details yet, just looking to
get a feel for it.  The largest chunk indeed is for leak tracking, so
that could be a nice feature oriented read (how the tracking works)
and the document shows us actually how the feature is used.

We have a leaky `x.c` program, that allocates 10240 bytes 3 times, then
calls free just on the last allocation and finally allocates 1000 bytes
again.

There's a way to grab the instrumentation data via {MAN}/gdb[`gdb`],
even if the program itself is not running with malloc opts that allow
grabbing this data.  So I assume the option only causes a dump, and
those stats are always grabbed if `malloc` is compiled with
`MALLOC_STATS`. It also shows how to go from the stored `f` address to
a line of code in `gdb`. `malloc` options are documented in
{MAN}/malloc.conf.5[`malloc.conf(5)`].

For now, let's go over the available `malloc` options and set a goal
to learn what is the default and how the options are read/parsed,
including the implementation details (as the symbolic link in examples
seems interesting).

So from `malloc.conf` we learn, upon the first call to the `malloc(3)`
family of functions, an initialization sequence inspects the symbolic
link `/etc/malloc.conf`, next checks the environment for a variable
called `MALLOC_OPTIONS`, and finally looks at the global variable
`malloc_options` in the program. Each is scanned for the following
flags. Flags are single letters. Unless otherwise noted uppercase
means on, lowercase means off.

I assume 'first call' is per program I checked on my boxes and none
have `malloc.conf` by default.  Obviously none also define
`MALLOC_OPTIONS` as for the flag itself.  The man page goes over them
pretty clearly, so no point of me copy pasting info here.  One
interesting bit so far, is `D` ("Dump"), `malloc(3)` will dump
statistics to the file `./malloc.out`, if it already exists, at exit.

Worth to check how it the code behaves when the file is present or
not, the doc makes me think it will never dump unless the file is
pre-created.  `F` is the freeguard for delayed frees.

NOTE: It won't dump unless the file is there and it will warn you
      about that on stderr.

Looks like `PROT_*` does detect double free and the code suggests that
with using `U` with `F`. This option is intended for debugging rather
than improved security (use the `U` option for security). On `U`
("Free unmap"), enable use after free protection for larger
allocations. Unused pages on the freelist are read and write protected
to cause a segmentation fault upon access.

TIP: Use after free isn't quite the same as double free, but I think
     double frees of these pages may still be captured. I assume they
     would be removed from the hash table.  And re-inserted if they
     once they are put back to use.

`X` is also interesting, mostly because it shows up with an example on
how to compile in `malloc` options to binaries which makes me wonder
what happens if a program does runtime modifications to that
structure.

NOTE: This structure is never touched past first `malloc`. It's
      useless to modify it and would be a vulnerability vector if it
      had impact.

There are also two options for controlling the cache size. We also
learn that the default page cache is 64.

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define MALLOC_DEFAULT_CACHE    64
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[sh]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ln -s 'G<<' /etc/malloc.conf
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Creates a root owned symbolic link from the string? 'G<<' to a file
named `/etc/malloc.conf`. I predict that it follows the symlink to
find the linked to 'filename' and treat that as options.

IMPORTANT: `G<<` need to be a valid name (anything goes except nul or
           `/`). But it obviously need not point to any existing file
           as in doesn't have to exist.

Let's look at some code. Upon the first call to the `malloc(3)` family
of functions, an initialization sequence inspects the symbolic link
`/etc/malloc.conf`. This is mentioned as the first thing the code
does, so let's search for
{BXR}/lib/libc/stdlib/malloc.c#590[`/etc/malloc.conf`].

We are in `omalloc_init`, we can see cache being set to 64 with and
option junk set to 1. Junk option increase the junk level by one if it
is smaller than 2. Junking writes some junk bytes into the area
allocated.

Currently junk is bytes of `0xdb` when allocating; freed chunks are
filled with `0xdf`. By default the junk level is `1`: small chunks are
always junked and the first part of pages is junked after free. After
a delay (if not switched off by the `F` option), the 😶filling patter
is validated and the process is aborted if the pattern was
modified. If the junk level is `0` (zero), no junking is
performed. For junk level `2`, junking is done without size
restrictions.

Now we have a chunk of code executed up to 3 times.  Interesting
pattern I never saw before. The loop switches on the value picking a
patch.  On the first try we call {MAN}/readlink.2[`readlink(2)`] on
`/etc/malloc.conf`.

This follows the symlink placing the name of our 'fake' options file
in the buffer b.  Second path is only allowed if we are running
elevated, the code then reads the `MALLOC_OPTIONS` environment variable.

IMPORTANT: The environment variable is only respected if we are *not*
           `setuid`/`setgid`. `issetugid` return 1 if the process was
           suid. It's dangerous in general to respect environment
           variables set by a less privileged user.  I don't know if
           it's a big deal in this case.  But I guess the sysadmin
           could want all the security improving options on any
           process that starts at root and you don't want to let
           random users override that option with an environment
           variable.

Final path, is grabbing the potentially compiled in `malloc_options` and
finally parsing it.  There are 2 distinct paths for `S` and `s`:

 * `S` -> Enable all options suitable for security auditing;
 * `s` -> lower case version means turning it off.
 
First branch when spotting `S` calls omalloc-parseopt with `CGJ`.  So
canaries, guard pages and junking.

Second one disables all 3.  The final code path handles everything on
malloc options that is not `s` or `S`.  It's interesting that s also
sets default cache.  There's one thing that I am noticing right
now. There's a hierarchy:

[txt]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
malloc.conf < MALLOC_OPTIONS < malloc_options
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So if a program compiles `malloc_options` then there is no external way
to change it's flags and some programs utilize that feature.

NOTE: what would be the need of re-setting the malloc-cache in `s`?
      For a bit of hardening, I guess. If you have `S`, it disables
      the cache.  But someone wants to override that with `s` in the
      environment, what do you do? Line614

{BXR}/lib/libc/stdlib/malloc.c#omalloc_parseopt[`parseopt`] cache
sizes first, handled with bitshifts of malloc_cache then pretty much
boolean yes/no flags depending on the character, and finally a stderr
warning for unkown options and randomly enabled canary.

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     while ((mopts.malloc_canary = arc4random()) == 0)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

NOTE: That's less of an option, you can't even set it. It's just
      stored there, automatically.  It's not controlled by any
      flag. `mopts` stores other internal use data too.

The `dir_info` is protected by these canaries, `mopts` is read-only so
an attacker can't mess with the stored canary. If they somehow managed
to mess with `dir_info`, they'd have to know the canaries and write
them in the right spots.

== How junking works

`malloc.conf` informs us that there are 2 junking options, `J` and `j`.

 * `J` -> "More junking". Increase the junk level by one if it is smaller than 2.
 
 * `j` -> "Less junking". Decrease the junk level by one if it is
          larger than 0. Junking writes some junk bytes into the area
          allocated. Currently junk is bytes of `0xdb` when
          allocating; freed chunks are filled with `0xdf`. By default
          the junk level is 1: small chunks are always junked and the
          first part of pages is junked after free. After a delay (if
          not switched off by the `F` option), the filling pattern is
          validated and the process is aborted if the pattern was
          modified. If the junk level is zero, no junking is
          performed. For junk level 2, junking is done without size
          restrictions.
	  
The default options (`mopts.malloc_junk = 1;`) seen last time, say
junking is always happening.


{BXR}/lib/libc/stdlib/malloc.c#540 shows that the maximum junkings is
2 and minimum is 0.  The initial default is of course set in
`omalloc_init`.  Let's follow malloc_junk usage.

From the top, first hit comes from `unmap`, so this function works
with the malloc cache, and determines if the page needs to be given
back to the kernel.  It's not exposed externally.

If a page is larger than our defined cache we will just give the page back to the OS,
as no pint filling the whole cache with a single mapping,
then as long we have pages to unmap and still not went through available cache.

We free the region, and decrease our cache.  If caching failed, the
page is also released to the OS.  If after going through all available
cache slots we still have memory to unmap and we still have available
cache we again attempt to move the freed memory to the cache.  If this
fails, we zero out the memory if a clear flag is defined, then finally
hit our junking option. {BXR}/lib/libc/stdlib/malloc.c#387

That second option is `F`, so if we defined `J` and didn't define `F`
(or defined `f`) , there's an upper limit to how much of the page will
be junked defined as MALLOC_MAXCHUNK.

 *  which is a (1 << MALLOC_MAXSHIFT)
 *  which is a MALLOC_PAGESHIFT -1
 *  which is a PAGE_SHIFT
 *  which is a 14U
 *  so that's 8192 bytes

NOTE: maxchunk is half that, and page_shift is platform specific. see
      in {CVS}/src/usr/include/amd64/param.h[`param.h`].

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define PAGE_SHIFT 12
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


.Small test program
[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define PAGESHIFT (14U)
#define MAXSHIFT (PAGESHIFT - 1)
#define MAXCHUNK (1 << MAXSHIFT)
#include <stdio.h>
int
main(int argc, char **argv)
{
  	printf("%zu\n", MAXCHUNK);
	/* 2048 bytes on amd64 */
 	return 0;
}
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

21:26 < dxtr> PAGESHIFT vs PAGE_SHIFT
21:26 < DuClare> The 14U is for the __mips64__ branch
-->  I made a mistake
-->  didn't notice the defined for mips
-->  yep
21:26 < dxtr> what's the difference?

INFO: What's the difference between PAGESHIFT and PAGE_SHIFT?
[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define MALLOC_PAGESHIFT        (PAGE_SHIFT)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/usr/include/amd64/param.h:#define      PAGE_SHIFT      12
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

{BXR}/lib/libc/stdlib/malloc.c#390, we `memset` the memory up to the
calculated max chunk which now we know is platform dependant with
{BXR}/lib/libc/stdlib/malloc.c#SOME_FREEJUNK[`SOME_FREEJUNK`] which is
`0xdf` documented as `/* dead, free */`. There is also a `define
SOME_JUNK` with `0xdb` documented as `deadbeef` A helpful comment for
both:

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/*
 * What to use for Junk.  This is the byte value we use to fill with
 * when the 'J' option is enabled. Use SOME_JUNK right after alloc,
 * and SOME_FREEJUNK right before free.
 */
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So the decision here makes it easy when looking at memory hex dumps to
see if a part of memory was marked by the allocation or the free.  We
also recall from the document that malloc itself tests for those
patterns.  We started off with a place using `SOME_FREEJUNK`.  So
let's follow that symbol first, next uses show up in map.  This code
is also likely used for cache handling and is obtaining memory from
the cache.

We see 2 references to our symbol here, first thing, there's no limit
on the junking done.  Secondly the options are only triggered when
malloc junking is set to 2 (the `J` option).

The first path also happens only when `freeunmap` is set in ctualy
both use cases.  I'm having a hard time to grok it by just glossing
over, so will go from the top.  We start with a check for the canary
then if we didn't get a hint, nd the page shift size is larger than
our free regions size.  We grab new memory from the kernel and record
some stats, exiting execution . Otherwise, we go over each malloc
cache entry we have and try to obtain a fitting region from there. If
we find a proper page and we didn't have a hint and the size matches
the page shift size. We use that page and depending on the malloc
options.

 1. map it `READ|WRITE` for malloc `F` option;
 2.1 fill it with zero if zero_fill was passed;
 2.2 fill it with junk if `J` and `F` `malloc` options were used.

______________________________________________________________________

So the purpose for this here if I am reading this correctly is to junk
cache pages before they are given to the user.  As we saw before umap
only junked pages it was about to give back to the OS, pages going
back to cache are not junked on the default junking level and with J
when a program happens to get a cached page it will get additionally
junked. If the requested allocation is larger than the page size. It's
considered big and we proceed to the second if

21:52 < DuClare> unmap junks pages that go to the cache
21:53 < DuClare> There is no point junking pages that are handed off
to the OS
-->  ah, I miss identified the branches? /me checks backlog
-->  you are right
--> so this just rejunks the page, but has is indeed more junking as
    it's not restricted by MALLOC_MAXCHUNK

______________________________________________________________________

So I'm trying to wrap my head around what
{BXR}/lib/libc/stdlib/malloc.c#476[big `!= NULL`] branch does more
exactly.

There's a cached region bigger than what we're looking to map and it
split it by ofsetting into it. `big = r` points to the region info
which tracks its address and size. So by incrementing the pointer and
reducing the size, we effectively take away the start of the
region. `p`, which we'll return, points at what was the start of the
region, and then the region info is updated to point past the mapping
reserved for `p`.

Next occurrence is `validate_junk`
{BXR}/lib/libc/stdlib/malloc.c#1286[`malloc.c`]. This has just a
single call site in {BXR}/lib/libc/stdlib/malloc.c#1402[`ofree`]. The
function just goes over the memory to be freed and checks it byte by
byte if it matches `SOME_FREEJUNK`.

Let's go through `ofree`, to see when that happens.
{BXR}/lib/libc/stdlib/malloc.c#1306[`malloc.c`] first a bailout for
attempting to free a memory we don't have in our region info if check
is passed. We have branches for validating canaries and a malloc
guard. Next if the size is larger than `MALLOC_MAXCHUNK`.  We do some
checks but generally unmap otherwise if the freed page is fitting in
the `MALLOC_MAXCHUNK` size. We do a check for canaries/deleayed free
then if the memory was not asked to be cleared, and 'F' was not
defined and junking is defined.  We junk the memory and we already
know it's not past `MALLOC_MAXCHUNK` size followed by delayed free
handling.  In the other branch we either clear the memory as demanded
or fill it with junk.  In the first branch, past delayed free handling
we have the junk validation being executed, think that covers the free
junk handling.

== Memory junking allocation

{BXR}/lib/libc/stdlib/malloc.c#90[`malloc.c (line 90)`].  `SOME_JUNK`
`0xdb` is used as the pattern. Our first hit lands in malloc_bytes
{BXR}/lib/libc/stdlib/malloc.c#952[`malloc.c (line 952)`] from the
top, we start with the code checking the canary on `dir_info` and
bailing execution if it's corrupt.  Tthen we attempt to find an
already existing chunk of the requested size and create a new one if
we fail to do so.

Next we check the canary on the chunk itself, so `bp` is a page of
chunks.  Bits contains information on which chunks are free, if
there's more than one free chunk, we move our `chunk_start` forward by
the amount of bytes already in use.  Having a hard time grokking what
the bitwise and of total -1 is intended to do

______________________________________________________________________

NOTE: are those chunks just a bitmask?
21:54 < DuClare> You mean this one?  i &= bp->total - 1;
21:54 < DuClare> Or another one?
-->  generally the operations on i here
21:56 < DuClare> Well i is clearly used as an index into the bitmap
-->  I think it tries to find the first free spt in the chunk
22:00 < DuClare> Yes.  Or "first" -- notice the random nudge before the nested loops
-->  and the for loop inspects each checking on the bits mask to see if they are taken
-->  can you point the random nudge? my bit fiddling foo is weak
22:02 < DuClare> if (bp->free > 1)
-->  or can't see the forest for the trees to be more precise without a pen & paper
22:02 < DuClare>                 i += getrbyte(d);
-->  yes, that one calls init with the arc4random
-->  when you said between the loops I assumed between for (;;) and for(;;)
22:04 < DuClare> I said before the loops
______________________________________________________________________

We remove the page from the freelist if it has no more free chunks and
we store the allocation size as the chunk canary. Then we get to our
junking.

If `J` was set, we junk the allocated chunk with `SOME_JUNK` without a
size restriction.  Apparently `J` also excludes the use of chunk
canaries.  Looking at `fill_canary` ,it also uses the `SOME_JUNK`
pattern.  If the requested size is smaller than the allocated size and
larger than CHUNK_CHECK_LENGTH (32 bytes), the canarie would be filled
past the requested allocation to the end of the allocated space but
those features only exclude themselves when full junking (`J`) is on.

Jumping by `SOME_JUNK` I will also watch out, to not confuse canarie
checking code with the alloc junking, we can skip fill_canary and
validate_canary.

Next call lands in
http://bxr.su/OpenBSD/lib/libc/stdlib/malloc.c#1133[`omalloc`].  So
last we checked on amd64 MALLOC_MAXCHUNK I believe came out as 2k.  If
the requested allocation is smaller than that, it goes to malloc_bytes
and the comment states what we saw there , that it handles adding
SOME_JUNK.  Otherwise, we go through the other branch.

First malloc guard handling, then page rounding, then map which as we
read before goes through the cache and does handle junking but only
when it internally frees.  Same for unmap.  Again malloc guard
handling, if the request matches the whole allocation with juning set
to `J`, we junk the whole size minus the space needed for the malloc
guard.  If called with zero fill, this would get overwritten (again
leaving the malloc_guard untouched).

Otherwise, if the requested allocation is smaller than the page size,
we only junk the requested size minus the the malloc guard but if
asked to zero memory first, we would zero out up to the requested
allocation and junk the actual remainder of the allocated space.  If
`J` was not passed we would go to the canary handling we saw before

http://bxr.su/OpenBSD/lib/libc/stdlib/malloc.c#1488[`orealloc`] defers
to `omalloc` if called with a null pointer, then tries to find the
page in the directory.  If the page is not found, it reports a double
free.

Next a memory sanity check, we obtain the allocation size of the existing memory.
We prepare goldsz and gnewsz for malloc_guard size accounting

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/* First case: from n pages sized allocation to m pages sized
allocation, m > n */
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Rounding is done using the sized that include the guard pages,
obtaining memory from either cache and if that fails from the kernel.
After we have our memory on the gotit label for `J` we junk the newly
needed region then handle canaries. Apparently in this case `J`
doesn't conflict with canary handling.

In the next case, we effectively move the guard page down, marking the
old one read + write available and the new as PROT_NONE.  There is no
junking on this path.  As there is no place we could junk, the resize
however will result in FREEJUNK from the unmap.

Next junk the newly required region of the page, accounting to leave
the malloc guard untouched and again we handle canaries.  This again
is only done on `J`

Next, the chunk didn't change but the size did, so just junk past
previous needed size to the newly needed size

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/* create new allocation */
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

calls omalloc, we already went through how it adds junking.
error catch path, so that's don for orealloc.
final use of SOME_JUNK.

After a page is aligned, with `J` and zero fill we junk past the
requested size (which is probably already 0 filled) and avaioid
junking the malloc_guard.  If without zero fill, we junk the whole
page but without touching the malloc_guard , otherwise we again see
the canary handling.

So in summary, by default (junking == 1), allocations smaller than
MALLOC_MAXCHUNK will be junked on alloc. for junking == 2 we have no
size restrictions and junking is done far more often, including
reallocs and memaling.  The docs state:

[txt]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
After a delay (if not switched off by the F option), the filling
pattern is validated and the process is aborted if the pattern was
modified.'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

That appears to be true only for FREEJUNK as we didn't see any code
validating allocation junks.

NOTE: It detects the memory was touched, after being freed before
      being discarded (use-after-free). By contrast, overwriting the
      other junk is normal use


{BXR}/lib/libc/stdlib/malloc.c#976[`malloc.c`] So, first of all there
are different pages chunked at a different chunk size.  Minimum size
is 16, so on amd64 you'd get 256 chunks in a page.  So find_chunksize
is used to find the appropriate chunk size for the requested
allocation (smallest size that is large enough).  There can be
multiple chunked pages, we select one of the right size randomly.  Or
make a new page if we've run out Canary check we already saw Each
chunk info contains an array of bits, one for each chunk, indicating
whether it is free We grab an index to start from dir_info.  Notice
that this is shared across all chunk allocations, so making one such
allocation effectively permutes the order in which we search for a
chunk the next time Then if the page contains more than one free
chunk, we add a random byte-sized offset to the index to confuse
things further.

There is obviously no point in doing that if there is only one chunk
because we will find that one chunk anyway.  `bp->total` tells the
total number of chunks in the page, and it's a power of two.  So `i &=
bp->total - 1` reduces `i` modulo `bp->total`, to ensure we stay
within the valid range.  The bitfield is stored in an array so the
inner loop finds the element that i indexes into in that array, and
checks if any of the bits in that element are set.  If none are set,
we need to move forward so.  Each array element contains MALLOC_BITS
bits so by adding that quantity to i, it will index into the next
element.

MALLOC_BITS is obviously a power of two so masking i with
~(MALLOC_BITS - 1) clears the low bits of i, meaning it will index
into the first bit in the given array element.  This is important as
we'll see that the outer loop walks through the indices
sequentially. Doing this, the inner loop will eventually find and
break with an array element with some bits set, and unless it was the
first element, i will index into the first bit.  There's also the
obvious check that we do not run past the end of the bitfield
(bp->total bits), if we do, we'll loop to the start.

So now we come to the outer loop, with i indexing into some element
with at least one bit set, we use the modulo operator to clear the
high bits of i so we can focus on the 16 bits contained within the
element we've got we have now an index k into one of these 16 bits,
and we turn that into a corresponding bit mask u = 1 << k and with
that, we test if the bit in the bitfield is set, and if so, break,
because we found the free chunk.  Otherwise we increment i; it will
either index into the next bit in the same element (in which case the
inner loop break right away and we test that next bit, and so on).

Or it will index into the first bit of the next element. This whole
procedure is just a sequential search through the bit array, starting
at the index we drew from the dir_info.  After we located the free
chunk, we update the offset in dir_info to effectively permute the
next small malloc. Then using xor clear the bit to signify that our
chunk is no longer free: `*lp ^= u;`.

== How `G` option handling guard pages

On last malloc reads we went through `j` and `J` that hundle junking
the memory on allocation and frees (depending on the level).  Going
through that code path we saw code handling guard pages.

The `G` and `g` options are parsed as values to `mopts.malloc_guard`.
By default the value is unset in code, but since mopts is global it
will be set to 0.  When parsed, the options either explicitly set
`malloc_guard` to 0 (disable with `g`) or set the value to
{BXR}/lib/libc/stdlib/malloc.c#534[`MALLOC_PAGESIZE`].

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define MALLOC_PAGESIZE     (1UL << MALLOC_PAGESHIFT)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We know that malloc_pageshift is platform dependant and for our amd64
example it's defined as 12 ,so our MALLOC_PAGESIZE for amd64 is 4096
bytes and that's the value (on amd64) that is set to malloc_guard.

Now let's go over occurences of malloc_guard, from the top
{BXR}/lib/libc/stdlib/malloc.c#70.  First we have a set of macros
defined for calculating sizes for moves.  `malloc_guard` size is just
accounted for in those.  Next occurrence is found on line 142 inside
MALLOC_STATS not compiled in by default and as the comment states,
used to track how many bytes are actually spent on the malloc guards.
Next hit L190, the option defined in mopts and first code hit in
unmap.

We wen't over that one before fully so we won't go through the whole
flow again {BXR}/lib/libc/stdlib/malloc.c#386[`malloc.c`] the hit is
on L386 when unmap is called with the clear flag to zero out memory.
We actually account for the malloc_guard - the requested area is
zeroed and the guard is left untouched.

Next two hits are option parsing, we went over those before and then
we hit {BXR}/lib/libc/stdlib/malloc.c#1133[`omalloc`].

We know that maxchunk on our platform is 2048 bytes from our last
reads, if the requested allocation is smaller than last chunk (the
else branch) we have nothing of interest for us as malloc_bytes has no
malloc_guard handling code.

If the requested allocation is larger than 2048 bytes,
first check makes sure the requested memory is a sane vvalue,
accounting for the malloc guard and the page size.
If not, we bail with no memory.

Next, the requested size is increased by the size of the malloc_guard
(4k) and the size is rounded.  We then call map to obtain the memory
either from the OS or from our caches/freelist.  We don't remember any
guard page handling there.

Next we insert the newly allocated page into our directory, looking
inside insert, thhat's our freelist.  If that operation fails we call
unmap and it does have code for malloc_guard so let's jump there
briefly {BXR}/lib/libc/stdlib/malloc.c#unmap (L386).

`clear` is the last flag for `unmap` and we can see unmap being called
with clear '0' here.  So that code path iss not triggered.  Next block
is explicitly for malloc_guard (back on L1155).  At this point we have
a chunk of memory, we call mprotect on it passing the start of the
malloc guard page (psz - mopts.malloc_guard) and setting PROT_NONE for
the whole size of malloc_guard (4096 bytes)

This means that this page has no permissions (read, write, execute)
and attempting to do any of that on this part of memory would result
in a crash (ie. if the allocation was a string, and we tried to write
over it - we should crash) and since this is an option we can write a
test program just to see that in action.

Firstly let's go over the rest of the code.  Our junking code from
yesterday with `J` just accounts to not touch our malloc guard and now
we know why, I overlooked that yesterday.  If it tried to, we would
crash in the allocator itself as we just seet that page to PROT_NONE.

Same for `J` and when called we clear.  We just avoid touching the
page in the allocator.  The same can bee seen in the second branch, at
least for the `J` path and clearing.  There's an additional one for
chunk canaries and that's the same thing, it avoids touching the guard
page while writing the canary.  That's all for this code path.

http://bxr.su/OpenBSD/lib/libc/stdlib/malloc.c#1306[`ofree`], we saw
this code before and went over it so I'm going to focus on the paths
hitting malloc_guard.  When freeing large allocations (>2048 bytes):

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
1354        } else if (sz - mopts.malloc_guard < argsz) {
1355            wrterror(pool, "recorded size %zu < %zu",
1356                sz - mopts.malloc_guard, argsz);
1357        }
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

I just checked call sites for ofree and looks like the recorded size
is only passed from freezero

{BXR}/lib/libc/stdlib/malloc.c#1480[`malloc.c`] which is a fairly new
addition on {MAN}/freezero[freezero(-current)].

Used for the allocation of memory holding sensitive data, the
recallocarray() and freezero() functions guarantee that memory
becoming unallocated is explicitly discarded, meaning pages of memory
are disposed via munmap(2) and cached free objects are cleared with
explicit_bzero(3).  freezero has the size of the freed structure, so
that helps catching when the user asked to clear less memory than was
actually recorded as used by that allocation (accounting for the
malloc_guard size as unused).

Next there are 2 code paths.  Again no malloc_guard with the else
branch handling smaller than 2048 byte allocations.  In the >
MALLOC_MAXCHUNK branch we first check canaries and again we just avoid
the canary from touching the malloc_guard.

Next hit in the dedicated mopts.malloc_guard if there's a sanity
check, as the 'sz' contains the size of the requested memory including
the malloc_guard.  If that size is less than the malloc_guard then
this is an inconsistency, the check is then disabled if 'F' was
defined. this removes the PROT_NONE from the malloc_guard.

With 'F' we want to keep it, as 'F' is for detecting use after free so
having the page still protected is more likely to crash on use after
free.  Without that option there is no delayed freeing so this memory
is no longer considered protected and we just 'pull out' the malloc
guard from it.

{BXR}/lib/libc/stdlib/malloc.c#1488[`orealloc`], we also went over
this one before, so focusing only on malloc_guard.  First hit, size
sanity check we saw before in omalloc.  Next, if we the old size is
larger than 2048 bytes and the old size is smaller than the malloc
guard, then we have an inconsistency.  As it had to have a malloc
guard.  Next we do some account for hte malloc guard size when
resizing and our realloc cases.  Explicitly only runs when there is no
malloc_guard so we skip this one.

The old malloc_guard page region is marked as read|write and the new
region is marked as PPROT_NONE

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-->  - /* number of pages remains the same */
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Just 'J' handling, making sure it doesn't touch the protected
malloc_guard page and that's all for orealloc.

next orecallocarray,
again a check for the recorded size, same as we saw with freezero.
The old size can't be smaller than malloc_guard.

Next omemalign (http://bxr.su/s?refs=omemalign&project=OpenBSD).  We
went over the code for junking.  There is a sanity size check first
(for checking a request to more memory than we can give) then
accounting that the size needs to contain the malloc_guard around it
with malloc_guard enabled (protect the memory region with mprotect
PROT_NONE).  Then with junking and canaries just avoid touching the
protected area.

final occurences are in malloc_dump1 for stats reporting and for
malloc_exit.  That's also stats reporting. That code is not compiled
in by default.

Let's write a sample program that mallocs memory and writes past the
allocation, run it without 'G' then compile the program with malloc
options 'G' and re-test. We know that our allocation has to be larger
than 2048 to have the guard page added

NOTE: For bonus points, experiment with the size to try and find the
maximum number of bytes you can overrun due to alignment. (without `G`).

-->  yeah
-->  so without 'G'
-->  I get killed on page boundaries
-->  here's sample code without 'G'
-->  https://junk.tintagel.pl/no-guard.c

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include <stdio.h>
#include <stdlib.h>

#define SIZE 5096

int
main(int argc, char **argv)
{
  int i;
  char *buf;
  
  if ((buf = malloc(SIZE)) == NULL)
    err(1, NULL);
  for(i = SIZE; i < 2*SIZE; i++) {
    printf("Writing byte %d\n", i);
    buf[i] = 'A';
  }
  printf("%s\n", buf);
  return 0;
}
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.Output
[txt]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Writing byte 8190
Writing byte 8191
Writing byte 8192
Segmentation fault (core dumped)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now compiling with the guard (https://junk.tintagel.pl/guard.c). Goes
up to 8192 then segfaults

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include <stdio.h>
#include <stdlib.h>

#define SIZE 5096

extern char *malloc_options;

int
main(int argc, char **argv)
{
  int i;
  char *buf;

  malloc_options = "G";

  if ((buf = malloc(SIZE)) == NULL)
    err(1, NULL);
  for(i = SIZE; i < 2*SIZE; i++) {
    printf("Writing byte %d\n", i);
    buf[i] = 'A';
  }
  printf("%s\n", buf);
  return 0;
}
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

NOTE: The thing is, 'G' guarantees that you have a guard page with
      these large allocations. Without g, it is possible that another
      allocation is back to back with your new allocation However it
      is likewise entirely possible that you just run off into
      unmapped space which kills you just as a guard page would.  With
      'G' there will always be something between me and another
      allocation.


== Malloc `C` option implementation

The documentation for 'C' states:

[txt]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
"Canaries". Add canaries at the end of allocations in order to detect
heap overflows. The canary's content is checked when free(3) is
called. If it has been corrupted, the process is aborted.
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Unlike guard pages this is not using mprotect.  Let's start with
mapping 'C' to an option and determining the default.  'C' and 'c'
alter the chunk_canaries flag on mopts.  We know mopts is global and
chunk_canaries are not explicitly set, so the default is 0 (canaries
off).  Let's follow usage from the top.

First the flag declaration, then the option parsing code, next we have
code we didn't hit on our previous reads
{BXR}/lib/libc/stdlib/malloc.c#733[`alloc_chunk_info`].  This
allocates the memory needed for the metadata holding the information
about a page.  This is internally used by malloc_bytes vie
omalloc_make_chunks.

First we calculate the size we need accounting for alignment, there is
apparently a free list for chunk metadata, which is separate from the
page free list. If there are no free chunk structures for reuse we ask
the OS for memory to create one ,the structure is initialy zeroed out
fully and on line 765 we see the chunk canary being set:

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
p->canary = d->canary1;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It's unconditional, we assume that's an internal structure integrity
canary unrelated to 'C'.

On line 745 we do have accounting for chunk canaries
{BXR}/lib/libc/stdlib/malloc.c#745.
From our previous reads we determined page size to be 4096 bytes on amd64
count is determined at the start of the function based on the requested allocation size:

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
738    if (bits == 0)
739        count = MALLOC_PAGESIZE / MALLOC_MINSIZE;
740    else
741        count = MALLOC_PAGESIZE >> bits;
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

minsize is 16 so for 0 bit allocations count would be 256 and our
canarie is count * sizeof(u_short) which is 2 bytes on my amd64
machine.

Trying to understand what the right shift is achieving here...  In the
else branch, it's shifting the page ize by the amount of requested
bits.  At this point I am not sure what it is actually accounting here
for, this is dividing the pagesize by power of two times equal to the
bits requested, but apart from this impacting how much memory is
memset at the end I don't see an impact/reason yet.

I will try to revisit this later in order to not stop us for too long

NOTE: It's the chunk size (2^bits), it just counts how many chunks fit
      in a page. With canaries enabled it has to account for each
      chunk having a 2 byte canary.

Next hit malloc_bytes.  We saw this code before, the first and second
canary occurences are for internal structures
{BXR}/lib/libc/stdlib/malloc.c#1016 is where we start to read (as we
read that code fully before). With chunk_canaries on we store the size
of our real allocation at the bits start for that chunk I assume that
information is needed so we don't overwrite the canary ourselves while
doing various operations on the memory like when reallocing.  On line
1024 we have our canary filled, we remember from previous read that
with 'J' on canaries don't work.  I think I didn't see that
documented, might be worth to check later.

Let's move on, fill_canary is the next function at line 1031.
`check_sz` is the size difference between the space allocated and the
size requested by the user, CHUNK_CHECK_LENGTH is defined as 32, so at
most we write 32 bytes for our canary after the requested allocated
size

Next function is our canary validation at L1041 validate_canary, it
does the same size restriction to limit it's work to up most 32 bytes
and then travels the memory byte by byte comparing if each byte
matches SOME_JUNK defined as 0xdb. This is the same one used for 'J'
mallocs.

Next occurrence omalloc.  We know malloc_bytes handles addng the
cnaaries so the else branch is covered, if the allocation takes the
whole page we don't add the canary which seem like I may be
misunderstanding what MALLOC_MOVE_COND does.

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
76#define MALLOC_MOVE_COND(sz)    ((sz) - mopts.malloc_guard <        \
77                    MALLOC_PAGESIZE - MALLOC_LEEWAY)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

So if the requested size is less than a pagesize, we don't add any
canaries.

Next up ofree, I expect more here as docs said the validation happens
here as in upon free.  We did go through that code before so scanning
for canaries.  First hit on 1337 is not checking a canary but
retrieving the size we saw stored.  In the bits flag before, that was
the size of actual requested allocation not including the added
canaries.  At this point if the size changed we have a corruption or
were asked to free more memory than we had (ie. via freezero).  For
larger allocations 2k on amd64, we call our validate_canary that will
check each byte being careful to not touch the guard page and again a
path for small allocations.

Stepping back to `sz <= MALLC_MAXCHUNK`.  That code path calls
find_chunknum and taking a look at find_chunknum reveals
{BXR}/lib/libc/stdlib/malloc.c#find_chunknum.  That it also validates
the canary scratch that. Last parameter tells it to sip the check, so
it's validated on L1392.

Next up {BXR}/lib/libc/stdlib/malloc.c#1488[`orealloc`]. we also read
this before On line 1529 we find the chunk info but find_chunknum is
called without being asked to validatethe canary.

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/* try to extend existing region */
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

-->  fills a new canary after the region is extended

______________________________________________________________________

22:30 < DuClare> 22:53 <@mulander> it has to account for each page having a 2 byte canary?
22:30 < DuClare> I'll note that those two bytes were used for the size, not the canary
-->  right
-->  DuClare: thanks, again :)
______________________________________________________________________


Unlike with guard pages, we don't have to worry about
unmapping/clearing the canary when resizing in orealloc but the new
one has to be filled at a proper place.  same for `/* shrink number of
pages */` and `/* number of pages remains the same */` branches. one
caveat is `/* do not reallocate if new size fits good in existing
chunk */` which stores the new size on the info page and fills the canary.

Next oreallocarray in line 1757, only contains a sanity check on the
recorded sizes as we saw before, the rest is handled via omalloc which
handles the canaries itself. The find_chunknum call here also is
instructed to not to verify the canary.

Next omemalign. We saw this one also, as a final step it fills the
canary and last use case is malloc_exit (which is just stats output
and not compiled in by default).

Now let's modify our example, to trigger a chunk canary
(https://junk.tintagel.pl/no-canary.c):

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include <stdio.h>
#include <stdlib.h>

#define SIZE 5096

extern char *malloc_options;

int
main(int argc, char **argv)
{
  int i;
  char *buf;

  malloc_options = "G";

  if ((buf = malloc(SIZE)) == NULL)
    err(1, NULL);
  for(i = SIZE; i < 8192; i++) {
    printf("Writing byte %d\n", i);
    buf[i] = 'A';
  }
  printf("%s\n", buf);
  free(buf);
  return 0;
}
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[sh]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Writing byte 8191
# echo $?
0
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

It has 'G' option compiled in and the guard page doesn't catch that we
overwrote the allocated memory as we stopped before hitting a guard
page (https://junk.tintagel.pl/canary.c) is the same code but with 'G'
flag changed to 'C'. compiled and ran:

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include <stdio.h>
#include <stdlib.h>

#define SIZE 5096

extern char *malloc_options;

int
main(int argc, char **argv)
{
  int i;
  char *buf;

  malloc_options = "C";

  if ((buf = malloc(SIZE)) == NULL)
    err(1, NULL);
  for(i = SIZE; i < 8192; i++) {
    printf("Writing byte %d\n", i);
    buf[i] = 'A';
  }
  printf("%s\n", buf);
  free(buf);
  return 0;
}
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.Output
[txt]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Writing byte 8190
Writing byte 8191
canary(98940) in free(): chunk canary corrupted 0x90249cc0000 0x13e8@0x13e8
Abort trap (core dumped)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This code detects that the canary was overwritten.
